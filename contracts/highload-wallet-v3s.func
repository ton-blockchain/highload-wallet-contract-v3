{-
  highload-wallet-v3s â€“ open-source optimized highload wallet for tvm-based blockchains (s - safest vesrion)

  Copyright (C) 2023 Continuation Team

  This file is part of highload-wallet-v3.

  highload-wallet-v3 is free software: you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  highload-wallet-v3 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License along with highload-wallet-v3.
  If not, see <https://www.gnu.org/licenses/>.
-}

#include "imports/stdlib.fc";


;;; Store binary true b{1} into `builder` [b]
builder store_true(builder b) asm "STONE";
;;; Stores [x] binary zeroes into `builder` [b].
builder store_zeroes(builder b, int x) asm "STZEROES";
;;; Store `cell` [actions] to register c5 (out actions)
() set_actions(cell actions) impure asm "c5 POP";

const int op::internal_transfer = 0xae42e5a4;


() recv_internal(cell in_msg_full, slice in_msg_body) {
  (int body_bits, int body_refs) = in_msg_body.slice_bits_refs();
  ifnot ((body_refs == 1) & (body_bits == (32 + 64))) {
    return ();
  }

  slice in_msg_full_slice = in_msg_full.begin_parse();
  int flags = in_msg_full_slice~load_uint(4);
  slice sender = in_msg_full_slice~load_msg_addr();

  if ((~ sender.equal_slice_bits(my_address())) | (flags & 1)) {
    return ();
  }

  int op = in_msg_body~load_uint(32);

  if (op == op::internal_transfer) {
    in_msg_body~skip_bits(64);
    cell actions = in_msg_body.preload_ref();
    set_actions(actions);
    set_code(my_code());
    return ();
  }
}


() recv_external(slice msg_body) {
  cell  msg_inner     = msg_body~load_ref();
  slice sign          = msg_body~load_bits(512);
  msg_body.end_parse();
  int   hash          = msg_inner.cell_hash();

  slice ds            = get_data().begin_parse();
  int   pubkey        = ds~load_uint(256);
  int   subwallet_id  = ds~load_uint(32);
  cell  old_queries   = ds~load_dict();
  cell  queries       = ds~load_dict();
  int   last_cleaned  = ds~load_uint(40);
  int   timeout       = ds.preload_uint(16);

  if (last_cleaned < (now() - timeout)) {
    (old_queries, queries) = (queries, null());
    if (last_cleaned < (now() - (timeout * 2))) {
      old_queries = null();
    }
    last_cleaned = now();
  }

  throw_unless(33, check_signature(hash, sign, pubkey));

  slice cs            = msg_inner.begin_parse();
  cell  message       = cs~load_ref();
  int   mode          = cs~load_uint(8);
  int   shift         = cs~load_uint(14);
  int   bit_number    = cs~load_uint(10);
  int   created_at    = cs~load_uint(40);
  int   _subwallet_id = cs~load_uint(32);
  cs.end_parse();

  throw_unless(34, _subwallet_id == subwallet_id);

  throw_unless(35, created_at == min(now(), max(created_at, now() - timeout)));

  (cell value, int f) = old_queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    throw_if(36, vs.preload_int(1));
  }

  (cell value, int f) = queries.udict_get_ref?(14, shift);
  builder new_value = begin_cell();
  if (f) {
    slice vs = value.begin_parse();
    (slice vs_tail, slice vs_head) = vs.load_bits(bit_number);
    throw_if(36, vs_tail~load_int(1));
    new_value = begin_cell().store_slice(vs_head).store_true().store_slice(vs_tail);
  } else {
    new_value = begin_cell().store_zeroes(bit_number).store_true().store_zeroes(1023 - bit_number - 1);
  }

  accept_message();

  queries~udict_set_ref(14, shift, new_value.end_cell());

  set_data(begin_cell()
          .store_uint(pubkey, 256)
          .store_uint(subwallet_id, 32)
          .store_dict(old_queries)
          .store_dict(queries)
          .store_uint(last_cleaned, 40)
          .store_uint(timeout, 16)
          .end_cell());


  commit();

  slice message_slice = message.begin_parse();
  {-
    extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))
               = ExtraCurrencyCollection;
    currencies$_ grams:Grams other:ExtraCurrencyCollection
               = CurrencyCollection;

    int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
      src:MsgAddressInt dest:MsgAddressInt
      value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
      created_lt:uint64 created_at:uint32 = CommonMsgInfo;

    message$_ {X:Type} info:CommonMsgInfo
      init:(Maybe (Either StateInit ^StateInit))
      body:(Either X ^X) = Message X;
  -}

  int constructor = message_slice~load_uint(1);
  throw_if(37, constructor);
  int flags = message_slice~load_uint(3);
  if (flags & 1) { return (); }
  message_slice~load_msg_addr();
  message_slice~load_msg_addr();
  message_slice~load_coins();
  message_slice = message_slice.skip_dict();
  message_slice~load_coins();
  message_slice~load_coins();
  message_slice~skip_bits(64 + 32);
  int maybe_stateinit = message_slice~load_uint(1);
  throw_if(37, maybe_stateinit); ;; throw if state-init included (state-init not supported)
  int either_body = message_slice~load_int(1);
  if (either_body) {
    message_slice~load_ref();
    message_slice.end_parse();
  }

  send_raw_message(message, mode | 2);
}


int get_public_key() method_id {
  return get_data().begin_parse().preload_uint(256);
}


int get_subwallet_id() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256);
  return ds.preload_uint(32);
}

int get_last_cleaned() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256 + 32 + 1 + 1);
  return ds.preload_uint(40);
}

int get_timeout() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256 + 32 + 1 + 1 + 40);
  return ds.preload_uint(16);
}

int processed?(int query_id) method_id {
  int shift      = query_id >> 10;
  int bit_number = query_id & 1023;

  slice ds           = get_data().begin_parse();
  ds~skip_bits(256 + 32);
  cell  old_queries  = ds~load_dict();
  cell  queries      = ds~load_dict();
  int   last_cleaned = ds~load_uint(40);
  int   timeout      = ds.preload_uint(16);

  if (last_cleaned < (now() - timeout)) {
    (old_queries, queries) = (queries, null());
    if (last_cleaned < (now() - (timeout * 2))) {
      old_queries = null();
    }
    last_cleaned = now();
  }

  (cell value, int f) = old_queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    if (vs.preload_int(1)) {
      return -1;
    }
  }

  (cell value, int f) = queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    if (vs.preload_int(1)) {
      return -1;
    }
  }

  return 0;
}