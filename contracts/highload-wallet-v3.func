{-
  highload-wallet-v3 â€“ open-source optimized highload wallet for tvm-based blockchains

  Copyright (C) 2023 Continuation Team

  This file is part of highload-wallet-v3.

  highload-wallet-v3 is free software: you can redistribute it and/or modify it under the terms
  of the GNU Lesser General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  highload-wallet-v3 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License along with highload-wallet-v3.
  If not, see <https://www.gnu.org/licenses/>.
-}

#include "imports/stdlib.fc";


;;; Store binary true b{1} to `builder` [b]
builder store_true(builder b) asm "STONE";

;;; Store `cell` [actions] to register c5 (out actions)
() set_actions(cell actions) impure asm "c5 POP";

builder store_zeroes(builder b, int x) asm "STZEROES";


() recv_internal() { }


() recv_external(slice msg_body) {
  cell  msg_inner     = msg_body~load_ref();
  slice sign          = msg_body~load_bits(512);
  msg_body.end_parse();
  int   hash          = msg_inner.cell_hash();

  slice ds            = get_data().begin_parse();
  int   pubkey        = ds~load_uint(256);
  int   subwallet_id  = ds~load_uint(32);
  cell  old_queries   = ds~load_dict();
  cell  queries       = ds~load_dict();
  int   last_cleaned  = ds~load_uint(40);
  int   timeout       = ds.preload_uint(16);

  if (last_cleaned < (now() - timeout)) {
    (old_queries, queries) = (queries, null());
    if (last_cleaned < (now() - (timeout * 2))) {
      old_queries = null();
    }
    last_cleaned = now();
  }

  throw_unless(33, check_signature(hash, sign, pubkey));

  slice cs            = msg_inner.begin_parse();
  cell  actions       = cs~load_ref();
  int   shift         = cs~load_uint(14);
  int   bit_number    = cs~load_uint(10);
  int   created_at    = cs~load_uint(40);
  int   _subwallet_id = cs~load_uint(32);
  cs.end_parse();

  throw_unless(34, _subwallet_id == subwallet_id);

  throw_unless(35, created_at == min(now(), max(created_at, now() - timeout)));

  (cell value, int f) = old_queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    throw_if(36, vs.preload_int(1));
  }

  (cell value, int f) = queries.udict_get_ref?(14, shift);
  builder new_value = begin_cell();
  if (f) {
    slice vs = value.begin_parse();
    (slice vs_tail, slice vs_head) = vs.load_bits(bit_number);
    throw_if(36, vs_tail~load_int(1));
    new_value = begin_cell().store_slice(vs_head).store_true().store_slice(vs_tail);
  } else {
    new_value = begin_cell().store_zeroes(bit_number).store_true().store_zeroes(1023 - bit_number - 1);
  }

  accept_message();

  queries~udict_set_ref(14, shift, new_value.end_cell());

  set_data(begin_cell()
          .store_uint(pubkey, 256)
          .store_uint(subwallet_id, 32)
          .store_dict(old_queries)
          .store_dict(queries)
          .store_uint(last_cleaned, 40)
          .store_uint(timeout, 16)
          .end_cell());

  set_actions(actions);
}


int get_public_key() method_id {
  return get_data().begin_parse().preload_uint(256);
}


int get_subwallet_id() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256);
  return ds.preload_uint(32);
}

int get_last_cleaned() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256 + 32 + 1 + 1);
  return ds.preload_uint(40);
}

int get_timeout() method_id {
  slice ds = get_data().begin_parse();
  ds~skip_bits(256 + 32 + 1 + 1 + 40);
  return ds.preload_uint(16);
}

int processed?(int query_id) method_id {
  int shift      = query_id >> 10;
  int bit_number = query_id & 1023;

  slice ds          = get_data().begin_parse();
  ds~skip_bits(256 + 32);
  cell  old_queries = ds~load_dict();
  cell  queries     = ds~load_dict();

  (cell value, int f) = old_queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    if (vs.preload_int(1)) {
      return -1;
    }
  }

  (cell value, int f) = queries.udict_get_ref?(14, shift);
  if (f) {
    slice vs = value.begin_parse();
    vs~skip_bits(bit_number);
    if (vs.preload_int(1)) {
      return -1;
    }
  }

  return 0;
}